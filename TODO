* AC matching

* Match BlankSequence and BlankNullSequence

* Finish implementing namespaces   
   
* Implement level specification

* Implement autoload. e.g. for code written in SJulia

* We can't disable infseval because it does some computation.

* Translation to and from SymPy is slow. For `Integrate' this is
usually not a problem. But, manipulation (eg Expand) of large expressions
may be hundreds of times faster in SymPy than the translation of the
result. Update: This happens at the PyCall level, not the SJulia level.

* [m, n] = [n, Mod(m, n)] Destructuring assignment

* gensyms that escape from Module can't be entered (parsed) at command line because of comment
 chars. Mma gensyms can be entered.  We need LModule only to remove temporary symbols. But,
 returned gensym symbols are entered again into the symbol table, with no special attributes.
  Mma gives gensyms attribute 'Temporary' and removes them when they go out of scope.
  We should use a separate gensym counter for SJulia, eg. $ModuleNumber.

* need a system for including packages and the associated sjulia capability only
 if the module is installed (or available)

* 'Do' with invalid iterator raises error. It shold warn and return unevaluated form.

* Allow user to set max number of mevals.

* Module should convert single line to compound expression.

* Getting error message "PyObject call" instead of unevaluated
 expression for, eg Integrate(x + c). Probably has to do
 with changing the REPL parsing code.

* Can't throw or handle exceptions correctly when translating AST.
   Find out why.
   
* Error messages have become shorter and more cryptic. Why
  e.g MethodError(SJulia._do_Comparison,(ex,==,((-1 + x) ^ 2) * (1 + 2 * x + 2 * (x ^ 2) + x ^ 3)))
  when comparing unbound symbol to polynomial

* Example message ErrorException("Symbol 'Part' is protected.").

* Warning message still appears for [a => b, ...]

* Map should map over values in a Dict.

* Map should map over multiple argument lists. Now it accepts only
  one argument list.
  "Map can be used in an operator form. For example Map(f)(expr)."
   This is wrong or incorrectly documented.

* Map needs to take level argument, and Heads -> True   

* Derivative. Expressions with expressions as the head. Implemented,
  but disabled because it breaks things. This can be fixed.

* Implement things like  Pi < 4 --> True. Maybe implement Pi like
   julia irrationals.

* Give exact values for CosD
   
   
###############################################################################

 ===  DONE ===

* N(Pi,1000) works
  but, N(Sqrt(2),1000) gives too few digits. We can get what we want
   by explicitly using SetPrecision.
   
* Allow user to set the output capture length   
   
* Partly done, answer is correct. Fix chained comparison. Remove true comparison. Return conjunction.
   
* O, OO, have problems. Need to evaluate them automatically
   
* @doap fails with annotated arguments. The type parameters need to be
   quoted ors something.a   
   
* Make Void (nothing, I think) meval to Null (better yet, avoid Void; explicitly return Null)
   
* Sympy  I * Infinity <--> DirectedInfinity[I]
   
*  Bug:
   ex = Exp(-t)*t^(a-1)
   Out(1) = E ^ (-t) * (t ^ (-1 + a))
   sjulia 2> Integrate(ex,t, conds => "none")
   WARNING: Gamma::argr: Gamma called with two arguments; one argument is expected.
   Out(2) = Integrate(ex,t,conds => "none")
   
* Use this test, or example. h([x_,y_]) := x^y

*  The result here should be simplified
   zz(aa(x_)) ^= x^2
   sjulia > zz(aa(3))
   3 ^ 2

*  Fixed. at least we get one level of subexpressions by calling mergeargs in sympy.jl
   Cos(Pi/6) returns unevaluated. Fix this, or use Sympy instead
   But, enabling the sympy version causes the dirty symbol test in
   evaluation_test.jl to fail. Sin will fail dirty symbol test because
   it is done by SymPy.

* When sum is unbound , we get this:
sjulia > Do( sum += i, [i,[1,2,3,4,5]])
1 + sum
ERROR: Too many meval entries 201
 in eval(::Module, ::Any) at ./boot.jl:237
Mma gives this:
AddTo::rvalue: sum is not a variable with a value, so its value cannot be
     changed.

* If needs third branch

* Allow multiline input at sjulia prompt (or from file ??) julia mode already
 does allow this. Check if parsed string returns Expr with head :incomplete


* Print sympy doc if no sjulia doc is available. Maybe even
  strip out the 'from sympyt import' part

* Integrate( Exp(-t)*t^(a-1),[t,0,Infinity])  fails because it returns an expression with type Base.#<,
  no idea what this object is. We should convert it to SJulia comparison, of course.
  For the moment we print an error.

  Fixed, but resdesign should be considered
* Reducing Times[]. When we get Infinity, we need to check for the numeric
  coefficient, so we can return DirectedInfinity[-1].
  How to do this efficiently ? We should probably compute the numeric part
  of the product as we do the analysis and then write a new array with only
  the non-numeric parts and work from there.  So, the entire procedure of
  removing numbers in sweeps will be replaced.

* Not true, or no longer: *** Yes, this works, but only on a list,
  which is how Count works. But, we could do it on args of any function.
  For instance cop = Count(_^2) defines a function that counts
  the number of arguments that have the form of a square.
  This does work: MatchQ( b^2, _^2)
